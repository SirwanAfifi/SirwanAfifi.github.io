{"componentChunkName":"component---src-templates-blog-details-js","path":"/blog/en/server-sent-events-and-react","result":{"data":{"markdownRemark":{"timeToRead":3,"frontmatter":{"date":"December 15th, 2019","title":"Server-Sent Events and React","tags":["React","Realtime","ASP.NET Core","Node.js"],"slug":" Server-Sent-Events-and-React/"},"html":"<p>Server Sents Events are realtime events sent from the server to the client. It's a way to subscribe to a data stream sent by a server. Basically, it is a long-running HTTP connection with a particular mime type. Contrary to WebSocket, Server-Sent Events are unidirectional which clients subscribe to a channel and get data from the server. Updates for the data are pushed to the client in realtime as they occur, so the client doesn't need to initiate any requests. When using SSE, we should consider these:</p>\n<ul>\n<li>Requests can be redirected HTTP 301(permanent) &#x26;\n307(temporary)</li>\n<li>Only UTF-8 decoding is supported, no binary data</li>\n<li>Protocol supports multiple type of events, default is message</li>\n<li>Clients always reconnect (no need to handle)</li>\n<li>Server sends HTTP 204 No Content to stop reconnection</li>\n<li>Limited amount of global connections per site</li>\n</ul>\n<h2>Server Implementation:</h2>\n<p>Implementing it on the server is pretty easy. All we need to do is running an endless loop. Inside the loop, we should set the somespecial HTTP headers and push the data to the response every 2 seconds:</p>\n<pre><code class=\"language-csharp\">public void Configure(IApplicationBuilder app, IWebHostEnvironment env,\n        ILogger&#x3C;Startup> loggerDebug, Datasource datasource)\n{\n    app.UseCors(\"MyPolicy\");\n\n    app.UseRouting();\n    app.UseEndpoints(endpoints =>\n    {\n        endpoints.MapGet(\"/stream\", async context =>\n        {\n            var response = context.Response;\n            response.Headers.Add(\"connection\", \"keep-alive\");\n            response.Headers.Add(\"cach-control\", \"no-cache\");\n            response.Headers.Add(\"content-type\", \"text/event-stream\");\n\n            while (true)\n            {\n                await response.Body\n                    .WriteAsync(Encoding.UTF8.GetBytes($\"data: {JsonSerializer.Serialize(datasource.GetData())}\\n\\n\"));\n\n                await response.Body.FlushAsync();\n                await Task.Delay(2 * 1000);\n            }\n\n        });\n    });\n}\n</code></pre>\n<p>Here's also a Node.js version of the server:</p>\n<pre><code class=\"language-js\">app.get(\"/stream\", (req, res) => {\n  res.set({\n    \"Content-Type\": \"text/event-stream\",\n    \"Cache-Control\": \"no-cache\",\n    Connection: \"keep-alive\",\n\n    // enabling CORS\n    \"Access-Control-Allow-Origin\": \"*\",\n    \"Access-Control-Allow-Headers\":\n      \"Origin, X-Requested-With, Content-Type, Accept\",\n  })\n\n  setInterval(() => {\n    res.write(`data: ${JSON.stringify(getData())}\\n\\n`)\n  }, 2000)\n})\n</code></pre>\n<p>As you can see, we are sending the data in a specific format:</p>\n<pre><code>data: My message\\n\\n\n</code></pre>\n<h2>Frontend Implementation</h2>\n<p>Implementing it on the client is fairly easy. All we need to do is making use of <code>EventSource</code> API, which is a standard interface to interact with the Server-Sent Events protocol. It basically opens a persistent connection to our HTTP server. The cool thing about the API is that it keeps the connection open until we call <code>EventSource.close()</code>:</p>\n<pre><code class=\"language-ts\">import React from \"react\"\n\nconst ProductList = () => {\n  const [data, setData] = React.useState([] as any)\n\n  const formatter = new Intl.NumberFormat(\"en-GB\", {\n    style: \"currency\",\n    currency: \"gbp\",\n  })\n\n  React.useEffect(() => {\n    let eventSource = new EventSource(\"http://localhost:5000/stream\")\n    eventSource.onmessage = e => updateProdutList(JSON.parse(e.data))\n  }, [])\n\n  const updateProdutList = (product: any) => {\n    setData([...product])\n  }\n\n  return (\n    &#x3C;table className=\"table table-hover\">\n      &#x3C;thead className=\"thead-dark\">\n        &#x3C;tr>\n          &#x3C;th>Id&#x3C;/th>\n          &#x3C;th>Title&#x3C;/th>\n          &#x3C;th>Price&#x3C;/th>\n        &#x3C;/tr>\n      &#x3C;/thead>\n      &#x3C;tbody>\n        {data.map((p: any) => (\n          &#x3C;tr key={p.Id}>\n            &#x3C;td>{p.Id}&#x3C;/td>\n            &#x3C;td>{p.Title}&#x3C;/td>\n            &#x3C;td>{formatter.format(p.Price)}&#x3C;/td>\n          &#x3C;/tr>\n        ))}\n      &#x3C;/tbody>\n    &#x3C;/table>\n  )\n}\n\nexport { ProductList }\n</code></pre>\n<p>Here we have passed in the SSE endpoint URL to the <code>EventSource</code> constructor. It then goes and establishes the communication channel between the React app and the server. Then we added <code>onmessage</code> event handler which is called when new data is received. <code>updateProdutList</code> is responsible for updating the state so once the data is received we update the state with the latest data. The process of subscribing to the endpoint happens once the <code>ProductList</code> component is mounted; that's why we used <code>useEffect</code> inside the component.</p>\n<p>Now we can test the application:</p>\n<img class=\"img-res\" src=\"/img/realtime.gif\" alt=\"Realtime communication\" />"}},"pageContext":{"slug":" Server-Sent-Events-and-React/"}},"staticQueryHashes":[]}