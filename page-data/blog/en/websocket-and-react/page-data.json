{"componentChunkName":"component---src-templates-blog-details-js","path":"/blog/en/websocket-and-react","result":{"data":{"markdownRemark":{"frontmatter":{"date":"March 8th, 2020","title":"WebSocket and React","tags":["React","Realtime","SignalR","ASP.NET Core","Node.js"],"slug":"WebSocket-and-React/"},"html":"<p>WebSocket is a communication protocol. It's bidirectional in nature which means that either client or server can send data at any time. With WebSocket, we can build applications such as multiplayer games, chat apps, collaboration software that work on the open web. In this blog, I going to show you how to create a WebSocket server both in .NET Core and Node.js. I'll start with the Node.js version as it's a bit easier (boilerplate code for it is just 13 lines of code).</p>\n<h2>WebSocket Server (Node.js)</h2>\n<p>To create a WebSocket server in Node.js we need to install a third-party package called <code>socket.io</code> which is pretty popular. So follow these steps to create the server:</p>\n<pre><code>mkdir -p websocket/node &#x26;&#x26; cd \"$_\"\nyarn init -y\nyarn add express socket.io\ntouch index.js\n</code></pre>\n<p>Now open <code>index.js</code> and add the following code:</p>\n<pre><code class=\"language-js\">const app = require(\"express\")()\nconst http = require(\"http\").createServer(app)\nconst io = require(\"socket.io\")(http)\n\nio.on(\"connection\", socket => {\n  socket.on(\"message\", message => {\n    socket.broadcast.emit(\"message\", message)\n  })\n})\n\nhttp.listen(8080, () => {\n  console.log(\"listening on *:8080\")\n})\n</code></pre>\n<p>As you can see we have initialized a new instance of <code>socket.io</code> using <code>http</code>. Then we added an event listener for the <code>connection</code> event. This keeps listening to any incoming WebSocket connection so whenever a new WebSocket connection is established from the client, the callback is invoked. Inside the callback again we keep listening to the incoming request from the newly created connection, If the client emits an event called <code>message</code> we broadcast the data to other subscribers. That's it, the backend part is done. Now let's create a frontend for it.</p>\n<h2>WebSocket Client</h2>\n<p>I don't want to explain the process of creating a React app as it's pretty easy to scaffold a React application using <code>create-react-app</code>. So let's assume that we have an existing application and want to add chat functionality to it. First, make sure you have installed <code>socket.io-client</code> package. I should also mention that I'm going to use Bootstrap for stylying the components. What we are going to build is this widget:</p>\n<img class=\"img-res\" src=\"/img/chat.png\" alt=\"Chat\" />\n<p>To create such component I'll break it down into two separate components, one for each single message and the other for the chat widget. So let's go ahead and create them:</p>\n<h3>Message component</h3>\n<pre><code class=\"language-js\">import React from \"react\"\nimport user from \"../Assets/user.png\"\nexport default ({ userName, message }) => {\n  return (\n    &#x3C;>\n      &#x3C;div className=\"media\">\n        &#x3C;img\n          className=\"rounded-circle align-self-start mr-3\"\n          src={user}\n          alt=\"Avatar\"\n        />\n        &#x3C;div className=\"media-body\">\n          &#x3C;h5 className=\"mt-0\">{userName}&#x3C;/h5>\n          &#x3C;p>{message}&#x3C;/p>\n        &#x3C;/div>\n      &#x3C;/div>\n      &#x3C;div className=\"dropdown-divider\">&#x3C;/div>\n    &#x3C;/>\n  )\n}\n</code></pre>\n<h3>Chat component</h3>\n<pre><code class=\"language-js\">import React, { useState, useEffect } from \"react\"\nimport \"./Chat.css\"\nimport Message from \"./Message\"\nimport socketIOClient from \"socket.io-client\"\nconst socket = socketIOClient(\"http://localhost:8080\")\n\nexport default () => {\n  const [userName, setUserName] = useState(\"\")\n  const [message, setMessage] = useState(\"\")\n  const [messages, setMessages] = useState([])\n\n  useEffect(() => {\n    const uName = prompt(\"Name?\")\n    if (uName) {\n      setUserName(uName)\n    }\n  }, [])\n\n  socket.on(\"message\", message => {\n    setMessages([...messages, message])\n  })\n\n  return (\n    &#x3C;div className=\"wrapper\">\n      &#x3C;div className=\"card border-primary\">\n        &#x3C;h5 className=\"card-header bg-primary text-white\">\n          &#x3C;i className=\"fas fa-comment\">&#x3C;/i> Chat\n        &#x3C;/h5>\n        &#x3C;div className=\"card-body overflow-auto\">\n          {messages.map((msg, index) => (\n            &#x3C;Message\n              key={index}\n              userName={msg.userName}\n              message={msg.message}\n            />\n          ))}\n        &#x3C;/div>\n        &#x3C;div className=\"card-footer border-primary p-0\">\n          &#x3C;div className=\"input-group\">\n            &#x3C;input\n              value={message}\n              onChange={e => {\n                setMessage(e.target.value)\n              }}\n              type=\"text\"\n              className=\"form-control input-sm\"\n              placeholder=\"Type your message here...\"\n            />\n            &#x3C;button\n              className=\"btn btn-primary btn-sm\"\n              onClick={_ => {\n                const msg = {\n                  id: Math.random() * 10,\n                  message,\n                  userName: userName,\n                }\n                setMessages([...messages, msg])\n                setMessage(\"\")\n\n                socket.emit(\"message\", msg)\n              }}\n            >\n              Send\n            &#x3C;/button>\n          &#x3C;/div>\n        &#x3C;/div>\n      &#x3C;/div>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>As you can see we first imported <code>socket.io</code>. Then there are three parts to make it work. The first part is to connect to our WebSocket server:</p>\n<pre><code class=\"language-js\">import socketIOClient from \"socket.io-client\"\nconst socket = socketIOClient(\"http://localhost:8080\")\n</code></pre>\n<p>The second part is to listen to incoming messages from the backend. As soon as there is a new message we save it into our local state:</p>\n<pre><code class=\"language-js\">socket.on(\"message\", message => {\n  setMessages([...messages, message])\n})\n</code></pre>\n<p>The third part is when we click on <code>Send</code> button which is simply emitting a new message to the WebSocket server:</p>\n<pre><code class=\"language-js\">socket.emit(\"message\", msg)\n</code></pre>\n<p>That's it. We just built a simple chat application in just a few minutes. Now let's create the same functionality using .NET Core.</p>\n<h2>WebSocket Server (.NET Core)</h2>\n<p>To create a WebSocket server in .NET Core we should use SignalR as it's incredibly simple yet powerful library to create real-time web applications. So let's type in the following commands to create a project:</p>\n<pre><code>mkdir -p websocket/dotnet &#x26;&#x26; cd \"$_\"\ndotnet new web\n</code></pre>\n<p>Next we need something called <code>Hub</code> which is a class for listening and emitting data to subscribers. So let's create a Hub called <code>ChatHub</code>:</p>\n<pre><code class=\"language-csharp\">public class ChatHub : Hub\n{\n    public async Task Message(MessageModel message)\n    {\n        await Clients.Others.SendAsync(\"message\", message);\n    }\n}\n\npublic class MessageModel\n{\n    public string UserName { get; set; }\n    public string Message { get; set; }\n}\n</code></pre>\n<p>Then we will need to configure the server to respond to WebSocket requests. So let's change <code>Startup.cs</code> as the following:</p>\n<pre><code class=\"language-csharp\">public class Startup\n{\n    public void ConfigureServices(IServiceCollection services)\n    {\n        services.AddCors(o => o.AddPolicy(\"CorsPolicy\", builder =>\n        {\n            builder\n            .AllowAnyMethod()\n            .AllowAnyHeader()\n            .WithOrigins(\"http://localhost:3000\");\n        }));\n        services.AddSignalR();\n    }\n    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n    {\n        app.UseCors(\"CorsPolicy\");\n\n\n        app.UseRouting();\n        app.UseEndpoints(endpoints =>\n        {\n            endpoints.MapHub&#x3C;ChatHub>(\"/chatHub\", options =>\n            {\n                options.Transports = HttpTransportType.WebSockets;\n            });\n        });\n    }\n}\n</code></pre>\n<p>It worth mentioning that SignalR includes some built-in transports to keep the underlying connection open. It means that it automatically chooses the most efficient transport type during an initial stage called negotiation. In the code, we have purposely set <code>WebSockets</code> transport by passing in a second argument to <code>MapHub</code> method. This is because the main focus of this blog post. But you can set other supported transports if you want to, If you don't explicitly set the transports, SignalR will use the most efficient type for you as mentioned. That's it. The server is now ready to communicate with the client. Unfortunately, the client part needs a couple of changes as the <code>socket.io-client</code> package doesn't support SignalR for its server as they are different in implementation. It means that we need to change the client code and the way it communicates with the server. First, we need to install an official Microsoft package:</p>\n<pre><code>yarn add @microsoft/signalr\n</code></pre>\n<p>Since the component structure is almost the same with one we had in <code>socket.io-client</code> so I'll just add the differences. First we need to import the SignalR package:</p>\n<pre><code class=\"language-js\">import {\n  HubConnectionBuilder,\n  LogLevel,\n  HttpTransportType,\n} from \"@microsoft/signalr\"\n</code></pre>\n<p>Then we need to have a way to initialize and open the connection. We could do that by defining a <code>useEffect</code> hook:</p>\n<pre><code class=\"language-js\">const [connection, setConnection] = useState();\n\nuseEffect(\n  configSocket();\n  // as before\n}, []);\n\nconst configSocket = async () => {\n  const socketConnection = new HubConnectionBuilder()\n    .configureLogging(LogLevel.Debug)\n    .withUrl(\"http://localhost:5000/chatHub\", {\n      skipNegotiation: true,\n      transport: HttpTransportType.WebSockets,\n    })\n    .build();\n  await socketConnection.start();\n  setConnection(socketConnection);\n}\n</code></pre>\n<p>We only want to initialize <code>connection</code> when the component mounts that's why we provided an empty array as a second argument for the effect hook. Next we need to listen to any incoming message:</p>\n<pre><code class=\"language-js\">connection &#x26;&#x26;\n  connection.on(\"message\", message => {\n    setMessages([...messages, message])\n  })\n</code></pre>\n<p>As the final step we need a way to emit the messages when a user clicks on <code>Send</code> button:</p>\n<pre><code class=\"language-js\">&#x3C;button\n  className=\"btn btn-primary btn-sm\"\n  onClick={_ => {\n    // as before\n\n    connection &#x26;&#x26; connection.invoke(\"message\", msg)\n  }}\n>\n  Send\n&#x3C;/button>\n</code></pre>\n<p>That's all we need to do to configure SignalR into our React application. Now you can run the project and see the result:</p>\n<img class=\"img-res\" src=\"/img/chat-demo.gif\" alt=\"Chat\" />\n<br/>\n<p><strong>Note</strong>: If you want to host the SignalR server on IIS you will have to enable WebSocket on IIS because it's not enabled by default. You can follow <a href=\"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/websockets?view=aspnetcore-3.1#iisiis-express-support\">this process</a> to enable it:</p>\n<img class=\"img-res\" src=\"/img/IIS_WebSocket.png\" alt=\"Enabling WebSockets on IIS\" />\n<br/>\n<p>Source code (<a href=\"https://github.com/SirwanAfifi/realtime\">https://github.com/SirwanAfifi/realtime</a>)</p>"}},"pageContext":{"slug":"WebSocket-and-React/"}},"staticQueryHashes":[]}