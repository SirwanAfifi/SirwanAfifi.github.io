{"componentChunkName":"component---src-templates-blog-details-js","path":"/blog/en/displaying-secured-images","result":{"data":{"markdownRemark":{"timeToRead":3,"frontmatter":{"date":"January 25th, 2020","title":"Displaying Secured Images","tags":["Node.js","Express","React","JavaScript"],"slug":"Displaying-Secured-Images/"},"html":"<p>Ran into an interesting problem this week with displaying secured images on the page. The problem is that <code>img</code> tag doesn't show the image if the resource is secured with a token or a username/password. When the browser encounters an image tag with a secured URL, it's unable to show the image, so it immediately responds with 401 Unauthorized error because the request is heading towards a protected resource. To show the problem, consider the following endpoint which requires the caller to pass in a token:</p>\n<pre><code class=\"language-js\">// server.js\napp.get(\"/downloadSecuredImage\", authentication, (req, res) => {\n  res.sendFile(`${__dirname}/images/Me.jpg`)\n})\n</code></pre>\n<p>As you can see, the Express framework provides a <code>sendFile()</code> method available on the response object which can be used to send static files to the client. It automatically sets appropriate headers to the response. I should also mention the token validation takes place using a custom Express middleware:</p>\n<pre><code class=\"language-js\">const jwt = require(\"jsonwebtoken\")\nconst database = require(\"../db/users\")\n\nconst authentication = async (req, res, next) => {\n  try {\n    const token = req.header(\"Authorization\").replace(\"Bearer \", \"\")\n    const decoded = await jwt.verify(token, \"SUPER_SECRET_PRIVATE_KEY\")\n    const user = database.users.some(u => u.email === decoded.user)\n    if (!user) {\n      throw new Error(\"Invalid credentials\")\n    }\n    req.user = decoded.user\n    next()\n  } catch (exception) {\n    console.log(exception)\n    res.status(401).send(exception)\n  }\n}\n\nmodule.exports = authentication\n</code></pre>\n<p>Now if we want an <code>img</code> tag to point to that endpoint, we get <code>401 Unauthorized</code> error, and the result would be the following image:</p>\n<img class=\"img-res\" src=\"/img/secured-image-401.png\" alt=\"secured-image\" />\n<p>One solution to tackle this issue is by embedding the image using a particular format. This format is called Data URL, and we can use it inside the image's <code>src</code> attribute, So the browser does not have to make another request to get it. Here is an example of how such Data URL looks like:</p>\n<pre><code>data:image/png;base64,R0lGODlhEAAQAM...\n</code></pre>\n<p>So we'll need to issue a request of type blob (<code>responseType: \"blob\"</code>) to the protected endpoint with the JWT token provided directly from the code. This way, we don't need to hard-code the URL inside <code>src</code> attribute anymore. Once the request is completed, we then assign the response data to a variable and make use of <code>FileReader</code>'s <code>readAsDataUrl</code> method to convert the blob result to Base64-encoded string. Here is a React component doing the process:</p>\n<pre><code class=\"language-tsx\">import React, { useState } from \"react\"\nimport axios from \"axios\"\n\nexport default () => {\n  const [token, setToken] = useState(\"\")\n  const [image, setImage] = useState&#x3C;string | ArrayBuffer | null>(\"\")\n\n  const downloadImage = async () => {\n    const img = await axios(`http://localhost:4000/downloadSecuredImage`, {\n      responseType: \"blob\",\n      headers: {\n        Authorization: `Bearer ${token}`,\n      },\n    })\n    const blob = img.data\n    let reader = new FileReader()\n    reader.readAsDataURL(blob)\n    reader.onload = () => {\n      console.log(reader.result)\n      setImage(reader.result)\n    }\n  }\n\n  return (\n    &#x3C;div className=\"container\">\n      &#x3C;div className=\"row\">\n        &#x3C;div className=\"col\">\n          &#x3C;div className=\"form-group\">\n            &#x3C;button\n              className=\"btn btn-info\"\n              onClick={_ => downloadImage()}\n              disabled={!token}\n            >\n              Download Image\n            &#x3C;/button>\n          &#x3C;/div>\n        &#x3C;/div>\n      &#x3C;/div>\n      &#x3C;div className=\"row\">\n        &#x3C;div className=\"col\">\n          &#x3C;img\n            src=\"http://localhost:4000/downloadSecuredImage\"\n            alt=\"This is a secured image....\"\n          />\n        &#x3C;/div>\n        &#x3C;div className=\"col\">\n          {image &#x26;&#x26; &#x3C;img src={image as string} alt=\"Image\" />}\n        &#x3C;/div>\n      &#x3C;/div>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>Now when the button is clicked we get the file from the server and save the converted result into a state, When the browser encounters the data URL (the value of <code>image</code>), It decodes the data and constructs the original file. This way, we have embedded the image data directly into the document.</p>\n<img class=\"img-res\" src=\"/img/SecureImageDemo.gif\" alt=\"SecureImageDemo\" />"}},"pageContext":{"slug":"Displaying-Secured-Images/"}},"staticQueryHashes":[]}