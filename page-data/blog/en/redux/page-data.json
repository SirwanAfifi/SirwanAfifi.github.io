{"componentChunkName":"component---src-templates-blog-details-js","path":"/blog/en/redux","result":{"data":{"markdownRemark":{"timeToRead":2,"frontmatter":{"date":"November 5th, 2019","title":"Redux","tags":["Redux","React","Programming Notes"],"slug":"Redux/"},"html":"<ul>\n<li>Redux is a predictable state container for JavaScript apps.</li>\n<li>The whole state of your app is stored in an object tree inside a single store.</li>\n<li>The only way to change the state tree is to emit an action.</li>\n<li>To specify how the actions transform the state tree, you write pure reducers:</li>\n</ul>\n<pre><code class=\"language-js\">const counter = (state = 0, action) => {\n  switch (action.type) {\n    case \"INCREMENT\":\n      return state + 1\n    case \"DECREMENT\":\n      return state - 1\n    default:\n      return state\n  }\n}\n\nconst { createStore } = Redux\nconst store = createStore(counter)\n\nconst render = () => {\n  document.body.innerText = store.getState()\n}\n\nstore.subscribe(render)\nrender() // calling once to render the initial state (0), then the subscribe will update subsequently\n\ndocument.addEventListener(\"click\", () => {\n  store.dispatch({ type: \"INCREMENT\" })\n})\n</code></pre>\n<ul>\n<li>Redux is very useful when you start getting a complicated data scenarios or complicate change of events.</li>\n<li>It's really going to simplify your application:</li>\n</ul>\n<img class=\"img-res\" alt=\"Redux is really going to simplify your application\" src=\"/img/redux.png\">\n<ul>\n<li>Setting up Redux is a bit confusing but once you set it up, it's going to pay off over the lifespan of the application.</li>\n<li>Store is immutable, we can't mutate any value on the store, we only ever create a brand new store object:</li>\n</ul>\n<pre><code class=\"language-js\">function createStore(reducer) {\n  let state\n  let listeners = []\n\n  const getState = () => state\n\n  const subscribe = listener => {\n    listeners.push(listener)\n    return () => {\n      listeners = listeners.filter(l => l !== listeners)\n    }\n  }\n\n  const dispatch = action => {\n    state = reducer(state, action)\n    listeners.forEach(listener => listener())\n  }\n\n  return {\n    getState,\n    subscribe,\n    dispatch,\n  }\n}\n</code></pre>\n<ul>\n<li>Subscribtions have to be added before dispatching actions.</li>\n</ul>\n<pre><code class=\"language-js\">// Library code\nfunction createStore(reducer) {\n  let state\n  let listeners = []\n\n  const getState = () => state\n\n  const subscribe = listener => {\n    listeners.push(listener)\n    return () => {\n      listeners = listeners.filter(l => l !== listener)\n    }\n  }\n\n  const dispatch = action => {\n    state = reducer(state, action)\n    listeners.forEach(listener => listener())\n  }\n\n  dispatch({})\n\n  return {\n    getState,\n    subscribe,\n    dispatch,\n  }\n}\n\nconst INCREMENT = \"INCREMENT\"\nconst DECREMENT = \"DECREMENT\"\n\n// Reducers\nconst counter = (state = 0, action) => {\n  switch (action.type) {\n    case INCREMENT:\n      return state + 1\n    case DECREMENT:\n      return state - 1\n    default:\n      return state\n  }\n}\n\nconst store = createStore(counter)\n\nconst unsubscribe = store.subscribe(() => {\n  console.log(store.getState())\n})\n\n// Action creators\nfunction incrementAction() {\n  return {\n    type: INCREMENT,\n  }\n}\nfunction decrementAction() {\n  return {\n    type: DECREMENT,\n  }\n}\n\nstore.dispatch(incrementAction())\nstore.dispatch(incrementAction())\nstore.dispatch(incrementAction())\nstore.dispatch(decrementAction())\n</code></pre>\n<ul>\n<li>We are going to wrap entire React application with one Provider component, So when the store changes it re-render the whole application.</li>\n</ul>"}},"pageContext":{"slug":"Redux/"}},"staticQueryHashes":[]}