{"componentChunkName":"component---src-templates-blog-details-js","path":"/blog/en/higher-order-components","result":{"data":{"markdownRemark":{"timeToRead":1,"frontmatter":{"date":"September 22nd, 2019","title":"Higher-Order Components","tags":["React"],"slug":"Higher-Order-Components/"},"html":"<p>Before we get started, we need to understand what a higher-order function is. In JavaScript functions are first-class citizens because they are treated like any other variables:</p>\n<ul>\n<li>They can be created using literals:</li>\n</ul>\n<pre><code class=\"language-js\">function myFunction() {\n  // function body\n}\n</code></pre>\n<ul>\n<li>They can be assigned to other types:</li>\n</ul>\n<pre><code class=\"language-js\">var myFunction = function() {\n  // function body\n}\nmyArray.push(function() {\n  // function body\n})\nmyObj.data = function() {\n  // function body\n}\n</code></pre>\n<ul>\n<li>A function can be passed to another function as an argument:</li>\n</ul>\n<pre><code class=\"language-js\">function invoke(myFunction) {\n  myFunction()\n}\n\ninvoke(function() {\n  // function body\n})\n</code></pre>\n<ul>\n<li>A function can return another function:</li>\n</ul>\n<pre><code class=\"language-js\">function myFunction() {\n  return function() {\n    // function body, inside this scope we can also have access to outter scope\n  }\n}\n</code></pre>\n<ul>\n<li>We can add new properties to a function:</li>\n</ul>\n<pre><code class=\"language-js\">var myFunction = function() {\n  // function body\n}\nmyFunction.name = \"Function name\"\n</code></pre>\n<h2>Higher-Order Component(Function)</h2>\n<p>Now talking about Higher-Order function makes more sense. A higher-order function is basically a function that can take another function as an argument, or returns a function as a result. In React it's pretty much the same concept; It takes a component as an argument and returns a component:</p>\n<pre><code class=\"language-js\">function MyComponent(Component) {\n  return class extends Component {\n    constructor(props) {\n      super(props)\n    }\n\n    render() {\n      return &#x3C;Component {...this.props} />\n    }\n  }\n}\n</code></pre>\n<p>It's great becuase we can wrap a component with another component; this means that we can add extra functionalities to a component so it can be usfuel to share common functionality between components without repeating code. They are often used for <code>cross-cutting</code> concerns. An example of it could be private routes inside a React application:</p>\n<pre><code class=\"language-js\">import React from \"react\"\nimport { Route, Redirect } from \"react-router-dom\"\nexport const PrivateRoute = ({ component: Component, ...rest }) => (\n  &#x3C;Route\n    {...rest}\n    render={props =>\n      isUserAuthenticated() ? (\n        &#x3C;Component {...props} />\n      ) : (\n        &#x3C;Redirect\n          to={{\n            pathname: \"/login\",\n            state: { from: props.location },\n          }}\n        />\n      )\n    }\n  />\n)\n</code></pre>\n<p>Here, the <code>PrivateRoute</code> is itself a function that is used to enhance another component. The way it enhance is to wrap the incoming component with <code>Route</code> component.</p>"}},"pageContext":{"slug":"Higher-Order-Components/"}},"staticQueryHashes":[]}